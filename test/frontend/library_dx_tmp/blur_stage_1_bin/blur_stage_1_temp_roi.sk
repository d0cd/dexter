include "src/dexter/synthesis/grammar.skh";

int ARRAY_LEN = 50;
int OFFSET = 0;

struct HBuffer{
  int[ARRAY_LEN] data;
  int width;
  int height;
}

bit HBuffer_equals(HBuffer o1, HBuffer o2) {
  if (o1.data != o2.data) return false;
  if (o1.width != o2.width) return false;
  if (o1.height != o2.height) return false;
  return true;
}

int index2D(int x, int y, int width){
  return (y * width) + x;
}

HBuffer HBuffer_Set(HBuffer buf, int x, int y, int val){
  return new HBuffer(data=lift_fn0(buf, val, x, y), width=buf.width, height=buf.height);
}

int HBuffer_Get(HBuffer buf, int x, int y){
  return buf.data[OFFSET + ((y * (buf.width)) + x)];
}

int cast_uint8_uint16(int val){
  return val;
}

int cast_uint8_uint32(int val){
  return val;
}

int cast_uint8_int16(int val){
  return val;
}

int cast_uint8_int32(int val){
  return val;
}

int cast_uint16_uint32(int val){
  return val;
}

int cast_uint16_int32(int val){
  return val;
}

int cast_uint16_int64(int val){
  return val;
}

int cast_int8_int16(int val){
  return val;
}

int cast_int8_int32(int val){
  return val;
}

int cast_int16_int32(int val){
  return val;
}

int cast_int32_int16(int val){
  return val;
}

int std_min(int v1, int v2){
  return (v1 > v2) ? 
    v2 : 
    v1;
}

int std_minf(int v1, int v2){
  return (v1 > v2) ? 
    v2 : 
    v1;
}

int std_max(int v1, int v2){
  return (v1 > v2) ? 
    v1 : 
    v2;
}

int std_maxf(int v1, int v2){
  return (v1 > v2) ? 
    v1 : 
    v2;
}

int std_abs(int v){
  return (v >= 0) ? 
    v : 
    (-(v));
}

int std_absf(int v){
  return (v >= (0)) ? 
    v : 
    (-(v));
}

int cast_int64_int32(int val);

int cast_uint16_float(int val);

int cast_int32_float(int val);

int cast_double_int64(int val);

int cast_double_uint8(int val);

int cast_double_int16(int val);

int cast_double_int32(int val);

int cast_int32_double(int val);

int cast_uint32_float(int val);

int cast_float_int32(int val);

int cast_uint8_float(int val);

generator bit inv_tmpl_1_gen(int lb_y, int ub_y, HBuffer out, HBuffer out_init, int ch0){
  return buf_asn_2d(lb_y, ub_y, 0, out.width, out, out_init) && (ch0 == 0 ? idn_2d(ub_y, out.height, 0, out.width, out, out_init) : idn_2d(0, lb_y, 0, out.width, out, out_init));
}

generator bit inv_tmpl_2_gen(int lb_y, int ub_y, int curr_y, int lb_x, int ub_x, HBuffer out, HBuffer out_init, int ch1, int ch2){
  return ((buf_asn_2d(lb_y, ub_y, 0, out.width, out, out_init) && (ch1 == 0 ? idn_2d(ub_y + 1, out.height, 0, out.width, out, out_init) : idn_2d(0, lb_y - 1, 0, out.width, out, out_init))) && buf_asn_1d(curr_y, lb_x, ub_x, out, out_init)) && (ch2 == 0 ? idn_1d(curr_y, ub_x, out.width, out, out_init) : idn_1d(curr_y, 0, lb_x, out, out_init));
}

bit buf_asn_2d(int lb_y, int ub_y, int lb_x, int ub_x, HBuffer out, HBuffer out_init){
  return lift_fn2(lb_x, lb_y, out, out_init, ub_x, ub_y);
}

bit idn_2d(int lb_y, int ub_y, int lb_x, int ub_x, HBuffer out, HBuffer out_init){
  return lift_fn4(lb_x, lb_y, out, out_init, ub_x, ub_y);
}

bit buf_asn_1d(int idx_y, int lb_x, int ub_x, HBuffer out, HBuffer out_init){
  return lift_fn5(idx_y, lb_x, out, out_init, ub_x);
}

bit idn_1d(int idx_y, int lb_x, int ub_x, HBuffer out, HBuffer out_init){
  return lift_fn6(idx_y, lb_x, out, out_init, ub_x);
}

int int_expr(int val){
  return (val < (2)) ? 
    (2) : 
    val;
}

generator int inv1_bnd_gen(HBuffer out, int y_init, int x_init, int x, int y, int ch3){
  return (ch3 == 0 ? 0 : ch3 == 1 ? out.width : ch3 == 2 ? out.height : ch3 == 3 ? y_init : ch3 == 4 ? x_init : ch3 == 5 ? x : y);
}

generator int inv0_bnd_gen(HBuffer out, int y_init, int x_init, int x, int y, int ch4){
  return (ch4 == 0 ? 0 : ch4 == 1 ? out.width : ch4 == 2 ? out.height : ch4 == 3 ? y_init : ch4 == 4 ? x_init : ch4 == 5 ? x : y);
}

bit pc(HBuffer input, HBuffer temp, int y, int x, HBuffer temp_init, int y_init, int x_init){
  return true && buf_asn_2d(0, temp.height, 0, temp.width, temp, temp_init);
}

bit inv0(HBuffer input, HBuffer temp, int y, int x, HBuffer temp_init, int y_init, int x_init){
  return true && (choose5 == 0 ? inv_tmpl_1_gen(inv0_bnd_gen(temp, y_init, x_init, x, y, choose4_23), inv0_bnd_gen(temp, y_init, x_init, x, y, choose4_24), temp, temp_init, choose0_22) : inv_tmpl_2_gen(inv0_bnd_gen(temp, y_init, x_init, x, y, choose4_26), inv0_bnd_gen(temp, y_init, x_init, x, y, choose4_27), inv0_bnd_gen(temp, y_init, x_init, x, y, choose4_28), inv0_bnd_gen(temp, y_init, x_init, x, y, choose4_29), inv0_bnd_gen(temp, y_init, x_init, x, y, choose4_30), temp, temp_init, choose1_25, choose2_25));
}

bit inv1(HBuffer input, HBuffer temp, int y, int x, HBuffer temp_init, int y_init, int x_init){
  return true && (choose6 == 0 ? inv_tmpl_1_gen(inv1_bnd_gen(temp, y_init, x_init, x, y, choose3_32), inv1_bnd_gen(temp, y_init, x_init, x, y, choose3_33), temp, temp_init, choose0_31) : inv_tmpl_2_gen(inv1_bnd_gen(temp, y_init, x_init, x, y, choose3_35), inv1_bnd_gen(temp, y_init, x_init, x, y, choose3_36), inv1_bnd_gen(temp, y_init, x_init, x, y, choose3_37), inv1_bnd_gen(temp, y_init, x_init, x, y, choose3_38), inv1_bnd_gen(temp, y_init, x_init, x, y, choose3_39), temp, temp_init, choose1_34, choose2_34));
}

int[ARRAY_LEN] lift_fn0(HBuffer buf, int val, int x, int y){
  int[ARRAY_LEN] r = buf.data;
  r[index2D(x, y, buf.width)] = val;
  return r;
}

bit lift_fn1(int idx_y, int lb_x, HBuffer out, HBuffer out_init, int ub_x){
  bit ret_val = true;
  for (int idx_x=lb_x; idx_x<ub_x; ++idx_x) {
    ret_val = ret_val && (HBuffer_Get(out, idx_x, idx_y) == int_expr(HBuffer_Get(out_init, idx_x, idx_y)));
  }
  return ret_val;
}

bit lift_fn2(int lb_x, int lb_y, HBuffer out, HBuffer out_init, int ub_x, int ub_y){
  bit ret_val = true;
  for (int idx_y=lb_y; idx_y<ub_y; ++idx_y) {
    ret_val = ret_val && (lift_fn1(idx_y, lb_x, out, out_init, ub_x));
  }
  return ret_val;
}

bit lift_fn3(int idx_y, int lb_x, HBuffer out, HBuffer out_init, int ub_x){
  bit ret_val = true;
  for (int idx_x=lb_x; idx_x<ub_x; ++idx_x) {
    ret_val = ret_val && (HBuffer_Get(out, idx_x, idx_y) == HBuffer_Get(out_init, idx_x, idx_y));
  }
  return ret_val;
}

bit lift_fn4(int lb_x, int lb_y, HBuffer out, HBuffer out_init, int ub_x, int ub_y){
  bit ret_val = true;
  for (int idx_y=lb_y; idx_y<ub_y; ++idx_y) {
    ret_val = ret_val && (lift_fn3(idx_y, lb_x, out, out_init, ub_x));
  }
  return ret_val;
}

bit lift_fn5(int idx_y, int lb_x, HBuffer out, HBuffer out_init, int ub_x){
  bit ret_val = true;
  for (int idx_x=lb_x; idx_x<ub_x; ++idx_x) {
    ret_val = ret_val && (HBuffer_Get(out, idx_x, idx_y) == int_expr(HBuffer_Get(out_init, idx_x, idx_y)));
  }
  return ret_val;
}

bit lift_fn6(int idx_y, int lb_x, HBuffer out, HBuffer out_init, int ub_x){
  bit ret_val = true;
  for (int idx_x=lb_x; idx_x<ub_x; ++idx_x) {
    ret_val = ret_val && (HBuffer_Get(out, idx_x, idx_y) == HBuffer_Get(out_init, idx_x, idx_y));
  }
  return ret_val;
}

harness void sketch(int[ARRAY_LEN] input_data, int input_width, int input_height, int[ARRAY_LEN] temp_data, int temp_width, int temp_height, int[ARRAY_LEN] temp_init_data, int temp_init_width, int temp_init_height, int x, int x_init, int y, int y_init) {
  HBuffer input = new HBuffer();
  int[ARRAY_LEN] _t0 = input_data;
  input.data = _t0;
  int _t1 = input_width;
  input.width = _t1;
  int _t2 = input_height;
  input.height = _t2;
  HBuffer temp = new HBuffer();
  int[ARRAY_LEN] _t3 = temp_data;
  temp.data = _t3;
  int _t4 = temp_width;
  temp.width = _t4;
  int _t5 = temp_height;
  temp.height = _t5;
  HBuffer temp_init = new HBuffer();
  int[ARRAY_LEN] _t6 = temp_init_data;
  temp_init.data = _t6;
  int _t7 = temp_init_width;
  temp_init.width = _t7;
  int _t8 = temp_init_height;
  temp_init.height = _t8;
  assert ((((!(inv1(input, temp, y, x, temp_init, y_init, x_init) && (x < (input.width)))) || inv1(input, HBuffer_Set(temp, x, y, int_expr(HBuffer_Get(temp, x, y))), y, x + 1, temp_init, y_init, x_init)) && ((!(inv1(input, temp, y, x, temp_init, y_init, x_init) && (!(x < (input.width))))) || inv0(input, temp, y + 1, x, temp_init, y_init, x_init))) && (((!(inv0(input, temp, y, x, temp_init, y_init, x_init) && (y < (input.height)))) || inv1(input, temp, y, 0, temp_init, y_init, 0)) && ((!(inv0(input, temp, y, x, temp_init, y_init, x_init) && (!(y < (input.height))))) || pc(input, temp, y, x, temp_init, y_init, x_init)))) && inv0(input, temp, 0, x, temp, 0, x);
}
int choose1_25 = ??(1);
int choose2_25 = ??(1);
int choose4_28 = ??(3);
int choose3_37 = ??(3);
int choose4_27 = ??(3);
int choose3_38 = ??(3);
int choose3_39 = ??(3);
int choose4_29 = ??(3);
int choose4_30 = ??(3);
int choose3_32 = ??(3);
int choose4_24 = ??(3);
int choose3_33 = ??(3);
int choose5 = ??(1);
int choose4_23 = ??(3);
int choose4_26 = ??(3);
int choose6 = ??(1);
int choose2_34 = ??(1);
int choose3_35 = ??(3);
int choose3_36 = ??(3);
int choose0_22 = ??(1);
int choose1_34 = ??(1);
int choose0_31 = ??(1);

int ashr (int v1, int v2);

int xor (int v1, int v2);

int band (int v1, int v2);

int bor (int v1, int v2);

int bnot (int v1);

int lshr (int v1, int v2) { 
  if (v2 == 0) return v1;
  if (v2 == 1) return v1 / 2;
  if (v2 == 2) return v1 / 4;
  if (v2 == 3) return v1 / 8;
  return -100;
}

int shl (int v1, int v2) { 
  if (v2 == 0) return v1;
  if (v2 == 1) return v1 * 2;
  if (v2 == 2) return v1 * 4;
  if (v2 == 3) return v1 * 8;
  return -100;
}